// NOTE(Noah): When we target the web like this,
// this means the web as of 2021, and before I invented the new version of the web.
// The Portable Programming Language compiles web projects like this to a static webpage.
#targets WEB_LEGACY

#include <std/console>
#include <std/gui>
#include <std/base>

// Includes the DOM type and DOM functions.
#include <std/web>

/*
    Here's how the web version of this might work...
    We want to use the JAM stack.
        That's Javascript, Markup, and API.
    
    We can compile PPL directly to webassembly.
    Call APIs no problem.
    And still use markup.
*/

// NOTE(Noah): Maybe the msg callback includes things like 
// if a button was pressed, etc.
void WindowMsgCallback();

// Called when the user opens the webpage.
// TODO(Noah): Figure out what happens on a page refresh.
int main(
    std::Terminal terminalRefs[],
    std::PhysicalScreenWindow windowRefs[]
) {
    int terminalId = -1;
    if ( len(terminalRefs) > 0 ) {
        terminalId = terminalRefs[0].id;
    }
    std::Print(terminalId, "\"Hello World\" from Portable Programming Language!");

    // NOTE(Noah): Because we are compiling this for the web, it should never
    // be the case that we are not already given a window.
    if ( len(windowRefs) > 0 ) {
        
        std::PhysicalScreenWindow window = windowRefs[0];
        window.SetTargetFPS(60);
        window.RegisterMessageCallback(WindowMsgCallback);
        unsigned int *backbuffer = std::Malloc( sizeof(unsigned int) * 500 * 500 );
        // On web, closing a window means closing the entire page.

        std::DOM dom = LoadDOM("web_helloworld.html");

        while(!window.ShouldClose()) {
            // On web, messages here are going to be either from Chrome or user keyboard.
            window.ProcessMessages();
            
            // Update the backbuffer
            {

            }

            // So here we are going to update the DOM, maybe here is where React might do rendering.
            {
                dom.BlitBufferToElement("canvas", backbuffer);
            }

            window.RenderDOM(dom); // will override the Buffer that was blit.
        }

        // Frankly, might do nothing on the web platform.
        window.Close();

    }

}