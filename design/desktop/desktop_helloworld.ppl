/*
Supported targets:
MAC_OS
WINDOWS
UNIX
UNITY_ENGINE
UNREAL_ENGINE
WEB_LEGACY
IPHONE
IPAD
APPLE_WATCH
META_QUEST
LYNX_R1
NVIDIA_GPU
BINARY_x86
BINARY_ARM
ARDUINO
*/

#targets MAC_OS, WINDOWS, UNIX

/* 
Gui is for creating programs that are going to display something to the user.
Like, maybe we want to make a window. Or draw some standardized gui elements.
*/
#include <std/gui> 

/* 
Console is a library used for writing things to some sort of console output.
There is color support. Support for utf8 and emojis.
Maybe we want to get user input.
We can create  / delete a console.
And potentially this is what we would use to call system commands (supposing we were on UNIX).
*/
#include <std/console> 

/*
Right now all this gives us is Malloc.
*/
#include <std/base>


// NOTE(Noah): Becuase I am lazy, I have not defined the input to this callback. Simply that it exists.
void WindowMsgCallback();

// Programs may be passed terminals or windows upon being invoked.
int main(
    std::Terminal terminalRefs[],
    std::PhysicalScreenWindow windowRefs[],
    int argc, char *argv[]
) {

    int terminalId = -1;
    if ( len(terminalRefs) > 0 ) {
        terminalId = terminalRefs[0].id;
    }

    // NOTE(Noah): If -1 is given for terminalId, Print fails silently. 
    std::Print(terminalId, "\"Hello World\" from Portable Programming Language!");
    
    /* 
        Using [] makes the type of array.
        PhysicalScreen has pixels + some DPI things likely.
        Maybe tells us if there are bezels + other odd things going on.
            - Like, is it curved?
            - What is the refresh rate of the screen?
    */
    std::PhysicalScreen screens[] = std::GetPhysicalScreens();

    // the app will do the most simple thing, i.e. make a window on the first screen...
    // NOTE(Noah): Stealing the len operator from Python and Odin.
    if ( len(screens) > 0 ) {

        std::PhysicalScreen screen = screens[0];
        /*
            NOTE(Noah): 
                '/' is used for decimal division.
                '//' is used for integer division.
        */
        int windowWidth = screen.width / 2;
        int windowHeight = screen.height / 2;
        int x = (screen.width - windowWidth) / 2;
        int y = (screen.height - windowHeight) / 2; 

        // NOTE(Noah): (0,0) follows proper coordinate systems. So it is based on bottom left of the screen.
        // and the window rect has (0,0) as bottom left.
        std::PhysicalScreenWindow window = std::CreatePhysicalScreenWindow(
            screens[0].id // which screen to create window on.
            "Window Title", // title of window.
            x, y, windowWidth, windowHeight, // window rect.
            WindowMsgCallback, // callback to handle window messages.
            STD_RGBA // pixel format for backbuffer.
        );

        // NOTE(Noah): We are doing "my" vesion of object-oriented code.
        // So what we do is store function pointers on structs. Thus, we can get away with having no new keyword.
        // If you want to store an "object" on the heap, use malloc.
        // There exists no private and public. Everything is public. Simple as that.
        window.SetTargetFPS(60);

        unsigned int *backbuffer = std::Malloc( sizeof(unsigned int) * windowHeight * windowWidth );

        // Main window loop.
        while(!window.ShouldClose()) {

            window.ProcessMessages();

            // Do shit like render to the window.
            // Bascially, draw some pixels to the backbuffer.

            // Then once we want to render to it, we simply point it to a buffer :)
            window.BlitBuffer(backbuffer);

        }
        window.Close();
    }
}