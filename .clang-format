---

# TODO(Noah):
# - If there is a multiline function decl, make it so that it does a break with the {
# - I want the break in switch statements to appear like, after {}
# - my goodness. Please get rid of the fact that it absolutely borks the definitions I have
# setup in grammer.h -> Same with things in lexer.h top of file. Annoying...

# NOTE(Noah): I am feeling the following. If I am to use clang-format, it needs to be SUPER stripped-down.
#    because I tend to like having control over how my code is formatted. But I do agree that there should be standardized
#    formatting styles in some instances.

Language:        Cpp
# BasedOnStyle:  LLVM

AlignAfterOpenBracket: AlwaysBreak
#someLongFunction(
#    argument1,
#    argument2);

AlignEscapedNewlines: DontAlign
#define A \
#  int aaaa; \
#  int b; \
#  int dddddddddd;

AlignOperands:   DontAlign

AllowAllArgumentsOnNextLine: true
# callFunction(
#    a, b, c, d)

AllowAllParametersOfDeclarationOnNextLine: true
# void myFunction(
#    int a, int b, int c, int d, int e);

AllowShortEnumsOnASingleLine: true
# enum { A, B } myEnum;

AllowShortBlocksOnASingleLine: Always
# while (true) { continue; }

AllowShortCaseLabelsOnASingleLine: true
# switch (a) {                    
# case 1: x = 1; break;
# case 2: return;
#}     

AllowShortFunctionsOnASingleLine: All
AllowShortLambdasOnASingleLine: All
AllowShortIfStatementsOnASingleLine: Never

AllowShortLoopsOnASingleLine: true
# while (true) continue;

AlwaysBreakAfterReturnType: None
# for function, like for "int foo();" we want to keep int and foo on the same line

BinPackArguments: true
# void f() {
#  f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,
#    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
#}

BinPackParameters: false
# void f(int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}

# for BraceWrapping, relates to the {. On the same line or the next line? Wrapping
# means it is on the next line.
BreakBeforeBraces: Custom
BraceWrapping:
  AfterCaseLabel:  true
  AfterClass:      false
  AfterControlStatement: MultiLine
  AfterEnum:       false
  AfterNamespace:  false
  AfterObjCDeclaration: false
  AfterStruct:     false
  AfterUnion:      false
  AfterExternBlock: false
  BeforeCatch:     false
  BeforeElse:      false
  BeforeLambdaBody: false
  BeforeWhile:     false
  IndentBraces:    false
  SplitEmptyFunction: false
  SplitEmptyRecord: false
  SplitEmptyNamespace: false

ColumnLimit:     80

ContinuationIndentWidth: 4
#int i =         //  VeryVeryVeryVeryVeryLongComment
#  longFunction( // Again a long comment
#    arg);

DeriveLineEnding: true
#Analyze the formatted file for the most used line ending (\r\n or \n). UseCRLF is only used as a fallback if none can be derived.

DerivePointerAlignment: false
PointerAlignment: Right
# int *p, vs int* p

IndentAccessModifiers: false
# of and concerning public and private (and the sort) in class definitions

# Very important
IndentCaseLabels: true
IndentCaseBlocks: false


IndentPPDirectives: BeforeHash
#if FOO
  #if BAR
    #include <foo>
  #endif
#endif

IndentWidth:     4

IndentWrappedFunctionNames: false
# do not indent these because then it is not readable.

# Very important
KeepEmptyLinesAtTheStartOfBlocks: true
#true:                                  false:
#if (foo) {                     vs.     if (foo) {
#                                         bar();
#  bar();                               }
#}


MaxEmptyLinesToKeep: 1
#MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0
#int f() {                              int f() {
#  int = 1;                                 int i = 1;
#                                           i = foo();
#  i = foo();                               return i;
#                                       }
#  return i;
#}

PPIndentWidth:   -1
# The number of columns to use for indentation of preprocessor statements. 
# When set to -1 (default) IndentWidth is used also for preprocessor statements.

ReferenceAlignment: Pointer
# RAS_Pointer (in configuration: Pointer) Align reference like PointerAlignment.

ReflowComments:  false
# do not wrap comments if too long. Keep as is.

SortIncludes:    Never
# never sort include statements

ShortNamespaceLines: 1


SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCaseColon: false
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceAroundPointerQualifiers: Default
SpaceBeforeRangeBasedForLoopColon: true
SpaceInEmptyBlock: false
SpaceInEmptyParentheses: false

SpacesBeforeTrailingComments: 1
# int var = 1; // I am a trailing comment

#SpacesInAngles:  Never

SpacesInConditionalStatement: false
# if (a)

SpacesInContainerLiterals: true
# var arr = [ 1, 2, 3 ];  

SpacesInCStyleCastParentheses: false
# (int)

SpacesInLineCommentPrefix:
  Minimum:         1
  Maximum:         -1 # disabled
# // example comment with one space after '//' chars.

SpacesInParentheses: false
# (...) OR ( ... )
SpacesInSquareBrackets: false
SpaceBeforeSquareBrackets: false
# int a[5];

#BitFieldColonSpacing: Both

#StatementAttributeLikeMacros:
#  - Q_EMIT

#StatementMacros:
#  - Q_UNUSED
#  - QT_REQUIRE_VERSION

Standard:        c++11
TabWidth:        8
UseCRLF:         false
UseTab:          Never

#WhitespaceSensitiveMacros:
#  - STRINGIZE
#  - PP_STRINGIZE
#  - BOOST_PP_STRINGIZE
#  - NS_SWIFT_NAME
#  - CF_SWIFT_NAME
#...

